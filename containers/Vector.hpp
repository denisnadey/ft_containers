//
// Created by Matthos Denys on 1/16/22.
//
#ifndef VECTOR_HPP
# define VECTOR_HPP

// LIBS ========================================================================
# include <memory>
# include <algorithm>
# include <cstddef>
# include <tgmath.h>
#include "utils/utils.hpp"
#include "utils/random_access_iterator.hpp"

//# include "./utils/random_access_iterator.hpp"

// =============================================================================

// CLASS DEFINITIONS ===========================================================

namespace ft
{
    template < class T, class Alloc = std::allocator<T> >
    class vector
    {
    public:

        /*
        ** Первый параметр шаблона (T)
        */
        typedef T                                           value_type;

        /*
        ** Второй параметр шаблона (Alloc)
        */
        typedef Alloc                                       allocator_type;

        /*
        ** allocator_type::reference
        ** Тип предоставляет ссылку на элемент, хранящийся в
        ** векторе.
        ** По умолчанию аллокатор является ссылкой на тип value_type
        ** (value_type&)
        */
        typedef typename allocator_type::reference          reference;

        /*
        ** тип_распределителя::const_reference
        ** Тип, дающий ссылку на хранимый const-элемент.
        ** Используется для чтения и выполнения оператора const.
        ** Тип const_reference не может быть использован для изменения значения
        ** элемента.
        ** По умолчанию распределитель является const-ссылкой на тип_значения
        ** (const value_type&)
        */

        typedef typename allocator_type::const_reference    const_reference;

        /*
        ** тип_распределителя::указатель
        ** Тип, дающий указатель на хранимый элемент.
        ** Указатель типа может быть использован для изменения значения
        ** элемента.
        ** По умолчанию аллокатор является указателем на value_type
        ** (value_type*)
        */
        typedef typename allocator_type::pointer            pointer;

        /*
        ** allocator_type::const_pointer
        ** Тип, дающий const-указатель на хранимый элемент.
        ** Не может быть использован для изменения значения элемента.
        ** Для доступа к элементу предпочтительнее использовать итератор.
        ** По умолчанию аллокатором является const-указатель на value_type
        ** (const value_type*)
        */

        typedef typename allocator_type::const_pointer      const_pointer;

        /*
        ** Итератор произвольного доступа к value_type.
        ** Который может читать или изменять любой хранящийся элемент.
        ** Преобразуется в const_iterator;
        */

        typedef ft::random_access_iterator<value_type>               iterator;

        /*
        ** Итератор произвольного доступа к const value_type.
        ** Который может читать сохраненные элементы.
        */

        typedef ft::random_access_iterator<const value_type>            const_iterator;

        /*
        ** ft::reverse_iterator<iterator>
        ** Который может читать или изменять любой элемент в обратном векторе.
        ** Используется для обратного итерационного перехода по вектору.
        */

        typedef ft::reverse_iterator<iterator>             reverse_iterator;

        /*
        ** ft::reverse_iterator<const_iterator>
        ** Может читать любой элемент в обратном векторе.
        ** Не может быть использован для модификации, используется для итерации через
        ** вектор в обратном направлении.
        */

        typedef ft::reverse_iterator<const_iterator>       const_reverse_iterator;

        /*
        ** Знаковый интегральный тип:
        ** Обычно такой же, как ptrdiff_t.
        ** Может представлять разницу между итераторами к
        ** Элемент, который фактически хранится.
        ** Может быть описан как количество элементов между двумя указателями.
        ** (Указатель на элемент содержит его адрес).
        */

        typedef typename ft::iterator_traits<iterator>::difference_type    difference_type;

        /*
        ** Беззнаковый интегральный тип, который может представлять любое
        ** неотрицательное значение типа difference_type.
        ** Обычно то же самое, что size_t.
        */

        typedef typename allocator_type::size_type          size_type;

        // Конструкторы:

        /*
        ** @brief По умолчанию.
        ** Конструирует пустой контейнер, без элементов.
        **
        ** @param Allocator object.
        ** Контейнер хранит и использует внутреннюю копию этого
        ** аллокатора. Это псевдоним второго параметра шаблона.
        ** Если в шаблоне этот второй аргумент не определен,
        ** будет использоваться std::allocator.
        */

        explicit vector (const allocator_type& alloc = allocator_type()) : _alloc(alloc), _start(u_nullptr), _end(u_nullptr), _end_capacity(u_nullptr)
        {}

        /*
        ** @brief Fill.
        ** Конструирует контейнер с "n" элементами.
        ** Каждый элемент является копией val.
        **
        ** @param n Количество элементов.
        ** @param val Элемент.
        ** @param allocator_type Объект аллокатора.
        */

        explicit vector (size_type n, const value_type& val = value_type(), const allocator_type& alloc = allocator_type()) : _alloc(alloc), _start(u_nullptr), _end(u_nullptr), _end_capacity(u_nullptr)
        {

        }

        /*
        ** @brief Range.
        ** Конструирует контейнер с таким количеством элементов, как.
        ** диапазон [first,last), причем каждый элемент строится из
        ** его соответствующего элемента в этом диапазоне, в том же порядке.
        ** (Адаптировано для борьбы с эффектом :
        ** vector(static_cast<size_type>(first), static_cast<value_type>(last), a))
        **
        ** @param first Итератор - первое значение в x.
        ** @param last Итератор - последнее значение в x.
        */

        template <class InputIterator>
        vector (InputIterator first, InputIterator last, const allocator_type& alloc = allocator_type(), typename ft::enable_if<!ft::is_integral<InputIterator>::value, InputIterator>::type* = u_nullptr) : _alloc(alloc)
        {

        }

        /*
        ** @brief Copy.
        ** Создайте вектор, инициализируя его содержимое
        ** копией каждого элемента из элементов "x" в
        ** том же порядке. Используйте распределитель копий "x".
        **
        ** @param "x" контейнер вектора для копирования.
        */


        vector (const vector& x)
                :
                _alloc(x._alloc),
                _start(u_nullptr),
                _end(u_nullptr),
                _end_capacity(u_nullptr)
        {

        }

        /*
        ** @brief Уничтожение объекта контейнера.
        ** Уничтожьте все элементы в контейнере и деаллоцируйте
        ** емкость контейнера.
        */

        ~vector()
        {

        }

        /*
        ** @brief Присваивает содержимое из "x" контейнеру.
        ** Заменяет содержимое this и в соответствии с размером.
        ** Все элементы до вызова уничтожаются.
        **
        ** @param x контейнер, который мы инспектируем.
        ** @return *this.
        */
        vector &operator=(const vector& x)
        {

        }

        // Iterators:

        /*
        ** @brief Возвращает итератор, указывающий на первый элемент
        ** в контейнере. Если контейнер пуст, то
        ** возвращенное значение итератора не будет разыменовано.
        ** Итератор имеет тип iterator (итератор произвольного доступа
        ** по ссылке value_type).
        **
        ** @return Итератор к первому элементу.
        */
        iterator begin() {  };

        /*
        ** @brief Возвращает итератор, указывающий на первый элемент
        ** в контейнере. Если контейнер пуст, то
        ** возвращенное значение итератора не будет разыменовано.
        ** Итератор имеет тип const_iterator (произвольный доступ
        ** итератор по ссылке типа const value_type).
        **
        ** @return Итератор к первому элементу.
        */
        const_iterator begin() const {  }

        /*
        ** @brief Возвращает итератор, указывающий на последний элемент.
        ** в векторном контейнере. Past-the-end - это теоретический элемент.
        ** следующий за последним элементом в контейнере. Если контейнер
        ** пуст, возвращается то же самое, что и begin.
        ** Итератор имеет тип iterator (итератор произвольного доступа
        ** по ссылке value_type).
        **
        ** @return Итератор к прошедшему концу элемента или begin, если
        ** контейнер пуст.
        */

        iterator end()
        {

        }

        /*
        ** @brief Возвращает итератор, указывающий на последний элемент.
        ** в векторном контейнере. Past-the-end - это теоретический элемент.
        ** следующий за последним элементом в контейнере. Если контейнер
        ** пуст, возвращается то же самое, что и begin.
        ** Итератор имеет тип const_iterator (произвольный доступ
        ** итератор по ссылке const value_type).
        **
        ** @return Итератор к прошедшему концу элемента или begin, если
        ** контейнер пуст.
        */

        const_iterator end() const
        {

        }

        /*
        ** @brief Дает обратный итератор, указывающий на последний элемент
        ** в контейнере (this->end() - 1).
        ** Это обратный итератор произвольного доступа.
        **
        ** @return Обратный итератор к обратному началу.
        */
        reverse_iterator rbegin() {  }

        /*
        ** @brief Дайте обратный итератор const, указывающий на последний
        ** элемент в контейнере (this->end() - 1).
        ** Это константный обратный итератор произвольного доступа.
        **
        ** @return A const обратный итератор к обратному началу.
        */
        const_reverse_iterator rbegin() const {  }

        /*
        ** @brief Дать обратную точку итератора к
        ** теоретический элемент, предшествующий первому элементу
        ** в контейнере.
        **
        ** @return the reverse iterator.
        */
        reverse_iterator rend() { }

        /*
        ** @brief Дайте const обратный итератор, указывающий на
        ** теоретический элемент, предшествующий первому элементу
        ** в контейнере.
        **
        ** @return the const reverse iterator.
        */
        const_reverse_iterator rend() const { }

        // Емкость:

        /*
        ** @brief Возвращает количество хранимых элементов.
        ** Оно не обязательно равно емкости хранилища.
        **
        ** @return Количество элементов в контейнере.
        ** (Беззнаковый интегральный тип)
        */
        size_type   size(void) const {

        }

        /*
        ** @brief Возвращает максимальное потенциальное количество элементов, которое может содержать вектор.
        ** вектор может содержать.
        ** Этот размер обусловлен известными системными или библиотечными ограничениями.
        ** Вектор не гарантированно будет иметь этот размер, он может
        ** провалить распределение, например.
        **
        ** Документация :
        ** https://www.viva64.com/en/a/0050/
        **
        ** @return Максимальное потенциальное количество элементов, которое может вместить данный
        ** контейнер может вместить.
        ** (Беззнаковый интегральный тип)
        */
        size_type   max_size(void) const { }

        /*
        ** @brief Изменяет размер контейнера так, чтобы он содержал "n"
        ** элемент. Если "n" меньше фактического размера.
        ** контейнер уменьшается до "n". Если больше,
        ** val вставляется в конец и в соответствии с емкостью
        ** системе расчета распределения.
        **
        ** @param n новый размер контейнера.
        ** @param val элемент для установки.
        */
        void        resize (size_type n, value_type val = value_type())
        {

        }

        /*
        ** @brief Возвращает размер выделенного объема памяти.
        ** Не обязательно равен размеру вектора. Может быть равен
        ** или больше, поскольку дополнительное пространство выделяется системой прогнозирования контейнеров.
        ** система распределения прогнозов.
        **
        ** @return Размер выделенного в данный момент объема памяти.
        ** Количество элементов, которые он может вместить.
        ** (Беззнаковый интегральный тип)
        */
        size_type   capacity (void) const { return (this->_end_capacity - this->_start); }

        /*
        ** @brief Возвращает, пуст ли контейнер.
        ** Не изменяет контейнер никаким образом.
        **
        ** @return true, если размер контейнера равен 0, false в противном случае.
        */
        bool        empty (void) const { }

        /*
        ** @brief Требуется, чтобы емкость вектора была, по крайней мере.
        ** достаточной для размещения "n" элементов.
        ** Если n больше, чем фактическая емкость, то перераспределение
        ** может произойти, иначе ничего не произойдет.
        **
        ** @param n запрашиваемая емкость.
        */
        void        reserve (size_type n)
        {

        }

        // Доступ к элементам:

        /*
        ** @brief Возвращает ссылку на элемент в
        ** позиции n в контейнере вектора.
        ** Если "n" находится вне диапазона, это вызывает неопределенное поведение.
        **
        ** @param n Позиция элемента в контейнере.
        ** @return Указанный элемент в позиции "n".
        */
        reference operator[] (size_type n) { return (*(_start + n)); }

        /*
        ** @brief Возвращает const ссылку на элемент в
        ** позиции n в контейнере вектора.
        ** Если "n" находится вне диапазона, это вызывает неопределенное поведение.
        **
        ** @param n Позиция элемента в контейнере.
        ** @return Указанный элемент в позиции "n".
        */
        const_reference operator[] (size_type n) const { return (*(_start + n)); }

        /*
        ** @brief Возвращает ссылку на элемент в
        ** позиции n в векторном контейнере.
        ** Основное отличие этой функции от
        ** оператора "[]" в том, что эта функция выбрасывает
        ** исключение std::out_of_range, если "n" находится вне диапазона
        ** контейнера.
        **
        ** @param n Позиция элемента в контейнере.
        ** @return Указанный элемент в позиции "n".
        */
        reference at (size_type n)
        {
            checkRange(n);
            return ((*this)[n]);
        }

        /*
        ** @brief Возвращает const ссылку на элемент в
        ** позиции n в векторном контейнере.
        ** Основное отличие этой функции от
        ** оператора "[]" в том, что эта функция выбрасывает
        ** исключение std::out_of_range, если "n" находится вне диапазона
        ** контейнера.
        **
        ** @param n Позиция элемента в контейнере.
        ** @return Указанный элемент в позиции "n".
        */
        const_reference at (size_type n) const
        {
            checkRange(n);
            return ((*this)[n]);
        }

        /*
        ** @brief Возвращает ссылку на первый элемент
        ** контейнера. Вызов этой функции на пустом контейнере
        ** вызовет неопределенное поведение.
        **
        ** @return Ссылка.
        */
        reference front () { return (*_start); }

        /*
        ** @brief Возвращает const ссылку на первый элемент
        ** контейнера. Вызов этой функции на пустом контейнере
        ** вызовет неопределенное поведение.
        **
        ** @return Ссылка const.
        */
        const_reference front () const { return (*_start); }

        /*
        ** @brief Возвращает ссылку на последний элемент в контейнере.
        ** Если контейнер пуст, возникает неопределенное поведение.
        **
        ** @return Ссылка на последний элемент.
        */
        reference back () { return (*(_end - 1)); }

        /*
        ** @brief Возвращает const ссылку на последний элемент в контейнере.
        ** Если контейнер пуст, возникает неопределенное поведение.
        **
        ** @return Ссылка const на последний элемент.
        */
        const_reference back () const { return (*(_end - 1)); }

        // Модификаторы:

        /*
        ** Диапазон (1)
        ** @brief Присваивает новое содержимое вектору, заменяя его текущее содержимое.
        ** содержимое, добавляя соответствующее изменение его размера.
        ** Новые элементы конструируются из каждого элемента в этом
        ** диапазоне, от первого до последнего, в том же порядке.
        **
        ** @param first - первый элемент в диапазоне.
        ** @param last последний элемент в диапазоне.
        */
        template <class InputIterator>
        void assign (InputIterator first, InputIterator last,
                     typename ft::enable_if<!ft::is_integral<InputIterator>::value, InputIterator>::type* = u_nullptr)
        {

        }

        /*
        ** @brief Назначение заполнения.
        ** Очистить контейнер, заполнить его val "n" раз.
        ** В соответствии с размером "n".
        **
        ** @param "n" количество элементов.
        ** @param "val" значение элемента.
        */
        void assign (size_type n, const value_type& val)
        {

        }

        /*
        ** @brief Добавляет новый элемент в конец вектора.
        ** Содержимое "val" копируется (перемещается) в новый элемент.
        **
        ** @param val Копируемое значение.
        */
        void push_back (const value_type& val)
        {

        }

        /*
        ** @brief Удаление последнего элемента контейнера.
        ** Уменьшить размер вектора на единицу.
        ** Если контейнер пуст, вызвать неопределенное поведение.
        */
        void pop_back()
        {

        }

        /*
        ** @brief Вставляет элемент в позицию. Может увеличивать размер
        ** контейнера. Это действие заставляет контейнер
        ** переместить все элементы, которые были после "postion"
        ** на их новые позиции.
        **
        ** @param position Позиция для вставки.
        ** @param val Элемент для вставки.
        ** @return Итератор к новому элементу в контейнере.
        */
        iterator insert (iterator position, const value_type& val)
        {

        }

        /*
        ** @brief Вставка элемента на "n" количество времени
        ** перед указанной позицией. Может увеличить вместимость
        ** контейнера. Это действие заставляет контейнер
        ** переместить все элементы, которые были после "позиции"
        ** на их новые позиции.
        **
        ** @param position Позиция для вставки.
        ** @param n Размер элемента для вставки.
        ** @param val Элемент для вставки.
        */
        void insert (iterator position, size_type n, const value_type& val)
        {

        }

        /*
        ** @brief Вставка элемента в диапазоне от ["first" до
        ** "last") по адресу "position". Может увеличить вместимость
        ** контейнера. Выброс, если заданный итератор недействителен.
        ** Перераспределить все элементы после интервала между первым и последним.
        **
        ** @param position позиция вставки.
        ** @param first первый элемент в диапазоне.
        ** @param last последний элемент в диапазоне.
        */
        template <class InputIterator>
        void insert (iterator position, InputIterator first, InputIterator last,
                     typename ft::enable_if<!ft::is_integral<InputIterator>::value, InputIterator>::type* = u_nullptr)
        {

        }

        /*
        ** @brief Удаление элемента из вектора в "позиции".
        ** Уменьшить размер на 1;
        **
        ** @param position итератор, указывающий на
        ** элемент для удаления.
        ** @return указатель на элемент a "&(*position) + 1";
        */
        iterator erase (iterator position)
        {

        }

        /*
        ** @brief Удалить элемент из вектора диапазон элементов.
        ** Уменьшите размер на количество удаленных элементов.
        **
        ** @param first первый элемент в диапазоне.
        ** @param last последний элемент в диапазоне.
        ** @return Итератор, указывающий на первый элемент.
        ** после "last".
        */
        iterator erase (iterator first, iterator last)
        {

        }

        /*
        ** @brief Заменяет содержимое на содержимое "x".
        ** "x" имеет тот же тип. Элементы "x" являются элементами
        ** этого контейнера, а элементы этого контейнера являются элементами "x".
        ** Все итераторы, ссылки, указатели на поменявшиеся местами
        ** объектах остаются действительными.
        **
        ** @param x вектор для обмена.
        */
        void swap (vector& x)
        {

        }

        /*
        ** @brief Удаляет (уничтожает) все элементы из
        ** контейнера. Конечный размер равен 0.
        */
        void clear()
        {

        }

    private:
        allocator_type  _alloc;
        pointer         _start;
        pointer         _end;
        pointer         _end_capacity;

        /*
        ** @brief Проверьте, находится ли "n" в диапазоне контейнера.
        ** Если "n" находится вне диапазона, это приведет к выбросу исключения std::out_of_range
        ** исключение.
        **
        ** @param n Позиция элемента для проверки.
        */
        void checkRange(const size_type& n) const
        {

        }
    };

    // Перегрузка функций, не являющихся членами

    /*
    ** @brief Сравнить векторный контейнер, чтобы узнать.
    ** равны ли они. Начать проверку, если размер
    ** отличается.
    **
    ** @param lhs вектор для сравнения с "rhs".
    ** @param rhs вектор для сравнения с "lhs".
    ** @return true, если они равны, false в противном случае.
    */
    template <class T, class Alloc>
    bool operator== (const ft::vector<T, Alloc>& lhs, const ft::vector<T, Alloc>& rhs)
    {

    }

    /*
    ** @brief Сравните векторный контейнер, чтобы узнать.
    ** если они различны. Эквивалентно !(lsh == rhs).
    **
    ** @param lhs вектор для сравнения с "rhs".
    ** @param rhs вектор для сравнения с "lhs".
    ** @return true, если они различны, false в противном случае.
    */
    template <class T, class Alloc>
    bool operator!= (const vector<T, Alloc>& lhs, const vector<T, Alloc>& rhs)
    {

    }

    /*
    ** @brief Сравните векторный контейнер, чтобы узнать.
    ** если элементы "lhs" лексикографически меньше, чем "rhs".
    **
    ** @param lhs вектор для сравнения с "rhs".
    ** @param rhs вектор для сравнения "lhs".
    ** @return true, если "lhs" лексикографически меньше, false в противном случае.
    */
    template <class T, class Alloc>
    bool operator<  (const vector<T, Alloc>& lhs, const vector<T, Alloc>& rhs)
    {

    }

    /*
    ** @brief Сравните векторный контейнер, чтобы узнать.
    ** если элементы "lhs" лексикографически меньше или равны элементам "rhs".
    **
    ** @param lhs вектор для сравнения с "rhs".
    ** @param rhs вектор для сравнения "lhs".
    ** @return true, если "lhs" лексикографически меньше или равен, false в противном случае.
    */
    template <class T, class Alloc>
    bool operator<= (const vector<T, Alloc>& lhs, const vector<T, Alloc>& rhs)
    {

    }

    /*
    ** @brief Сравните векторный контейнер, чтобы узнать.
    ** если элементы "lhs" лексикографически превосходят "rhs".
    **
    ** @param lhs вектор для сравнения с "rhs".
    ** @param rhs вектор для сравнения "lhs".
    ** @return true, если "lhs" имеет лексикографическое превосходство, false в противном случае.
    */
    template <class T, class Alloc>
    bool operator>  (const vector<T, Alloc>& lhs, const vector<T, Alloc>& rhs)
    {

    }

    /*
    ** @brief Сравните векторный контейнер, чтобы узнать.
    ** если элементы "lhs" лексикографически превосходят или равны "rhs".
    **
    ** @param lhs вектор для сравнения с "rhs".
    ** @param rhs вектор для сравнения "lhs".
    ** @return true, если "lhs" лексикографически превосходит или равен, false в противном случае.
    */
    template <class T, class Alloc>
    bool operator>= (const vector<T, Alloc>& lhs, const vector<T, Alloc>& rhs)
    {

    }

    /*
    ** @brief Overload of swap (vector).
    ** The contents of container are swaped.
    **
    ** @param x, y the containers to swap.
    */

    template <class T, class Alloc>
    void swap (vector<T,Alloc>& x, vector<T,Alloc>&y)
    {
    }
}

// =============================================================================

#endif